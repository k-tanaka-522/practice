AWSTemplateFormatVersion: '2010-09-09'
Description: |
  REST API Gateway - 包括的なAPIバックエンドシステム
  
  このテンプレートはスケーラブルなREST APIを構築します：
  
  【アーキテクチャ概要】
  ┌─────────────────────────────────────────────────────────────┐
  │                    REST API アーキテクチャ                      │
  ├─────────────────────────────────────────────────────────────┤
  │ Client → API Gateway → Lambda → DynamoDB/S3/SNS            │
  │   ↑           ↑           ↑          ↑                      │
  │ CORS      スロットリング  統合      データストア              │
  │ 認証      レート制限     エラー     通知システム             │
  │ API Key   キャッシュ     ハンドリング                        │
  └─────────────────────────────────────────────────────────────┘
  
  【主要コンポーネント】
  ◆ API Gateway (RESTful API)
    - Regional エンドポイント（低レイテンシ）
    - Cognito統合認証（JWT トークン検証）
    - API Key による追加認証
    - スロットリング・レート制限
    - CORS設定（ブラウザ対応）
    - CloudWatch統合監視
  
  ◆ Lambda Functions（ビジネスロジック）
    - Users API: ユーザー管理（CRUD操作）
    - Items API: アイテム管理（検索・フィルタリング）
    - VPC統合対応（セキュリティ強化）
    - 環境変数による設定管理
    - 詳細エラーハンドリング
  
  ◆ DynamoDB（NoSQLデータベース）
    - Pay-per-request課金（コスト最適化）
    - グローバルセカンダリインデックス（高速検索）
    - Point-in-time Recovery（データ保護）
    - 暗号化有効（セキュリティ）
    - DynamoDB Streams（変更追跡）
  
  ◆ S3（ファイルストレージ）
    - サーバーサイド暗号化
    - バージョニング（データ履歴）
    - ライフサイクル管理（コスト削減）
    - パブリックアクセス無効（セキュリティ）
  
  ◆ SNS（通知システム）
    - 非同期メッセージ配信
    - メール・SMS・Lambda統合
    - 高可用性・耐久性
  
  【セキュリティ機能】
  ✓ 多層認証（Cognito + API Key）
  ✓ IAM最小権限の原則
  ✓ VPC内Lambda実行
  ✓ 暗号化（保存時・転送時）
  ✓ API レート制限
  ✓ CloudWatch監視・アラート
  
  【パフォーマンス最適化】
  ✓ Regional API Gateway（低レイテンシ）
  ✓ Lambda同時実行制御
  ✓ DynamoDB GSI活用
  ✓ S3ライフサイクル管理
  ✓ CloudWatch ログ保持期間設定

Parameters:
  # ========================================
  # 環境・基本設定パラメータ
  # ========================================
  EnvironmentName:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]
    Description: |
      デプロイ環境名
      - dev: 開発環境（基本機能、短いログ保持）
      - staging: ステージング環境（本番同等設定）
      - prod: 本番環境（高可用性、長期ログ保持）

  ProjectName:
    Type: String
    Default: rest-api
    Description: |
      プロジェクト名（リソース命名に使用）
      例: rest-api → rest-api-dev-users-table
      命名規則: {ProjectName}-{Environment}-{ResourceType}

  # ========================================
  # ネットワーク設定パラメータ
  # ========================================
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: |
      Lambda関数を配置するVPC ID
      - 指定時: VPC内でLambda実行（セキュリティ強化）
      - 未指定時: パブリック実行（シンプル構成）
      ※VPC使用時は NAT Gateway が必要
    Default: ''

  PrivateSubnetIds:
    Type: CommaDelimitedList
    Description: |
      Lambda関数用プライベートサブネットIDリスト
      - 複数AZ指定で高可用性確保
      - プライベートサブネット推奨（セキュリティ）
      - NAT Gateway経由でインターネットアクセス
      例: subnet-12345,subnet-67890
    Default: ''

  # ========================================
  # 認証・セキュリティ設定パラメータ  
  # ========================================
  CognitoUserPoolArn:
    Type: String
    Description: |
      Cognito User Pool ARN（JWT認証用）
      - 指定時: JWT トークン認証有効
      - 未指定時: 認証なし（パブリックAPI）
      例: arn:aws:cognito-idp:region:account:userpool/pool-id
    Default: ''

  ApiKeyRequired:
    Type: String
    Default: 'false'
    AllowedValues: ['true', 'false']
    Description: |
      API Key認証の必須化
      - true: API Key + Usage Plan でレート制限
      - false: 認証なし（開発・テスト用）
      ※本番環境では true 推奨

# ========================================
# 条件分岐設定
# パラメータ値に基づく設定の動的変更
# ========================================
Conditions:
  # 本番環境かどうか（ログ保持期間、アラーム設定に影響）
  IsProduction: !Equals [!Ref EnvironmentName, 'prod']
  
  # VPC使用有無（Lambda配置場所、セキュリティグループ作成に影響）
  UseVPC: !Not [!Equals [!Ref VpcId, '']]
  
  # Cognito認証使用有無（API Gateway認証設定に影響） 
  UseCognito: !Not [!Equals [!Ref CognitoUserPoolArn, '']]
  
  # API Key必須化（Usage Plan、API Key作成に影響）
  RequireApiKey: !Equals [!Ref ApiKeyRequired, 'true']

Resources:
  # ========================================
  # API Gateway REST API
  # メインのAPIエンドポイントとスロットリング設定
  # ========================================
  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub '${ProjectName}-${EnvironmentName}-api'
      Description: !Sub 'REST API for ${ProjectName} ${EnvironmentName}'
      
      # エンドポイントタイプ: REGIONALを使用
      # - REGIONAL: 同一リージョンからのアクセスに最適化（低レイテンシ）
      # - EDGE: CloudFront配信（グローバルアクセスに最適）
      # - PRIVATE: VPC内アクセスのみ（最高セキュリティ） 
      EndpointConfiguration:
        Types:
          - REGIONAL
      
      # APIポリシー: API Key必須時のリージョン制限
      # セキュリティ強化: 特定リージョンからのみアクセス許可
      Policy: !If
        - RequireApiKey
        - Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Principal: '*'
              Action: execute-api:Invoke
              Resource: '*'
              Condition:
                StringEquals:
                  'aws:RequestedRegion': !Ref AWS::Region
        - !Ref 'AWS::NoValue'
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # Cognito JWT 認証オーソライザー
  # JWT トークンを使用したユーザー認証
  # ========================================
  CognitoAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Condition: UseCognito
    Properties:
      Name: !Sub '${ProjectName}-${EnvironmentName}-cognito-authorizer'
      RestApiId: !Ref RestApi
      
      # Cognito User Pool 認証タイプ
      # JWT トークンの検証とユーザー情報抽出を自動化
      Type: COGNITO_USER_POOLS
      
      # 認証プロバイダー: 複数のUser Pool指定可能
      ProviderARNs:
        - !Ref CognitoUserPoolArn
      
      # トークン取得元: Authorization ヘッダーから JWT 抽出
      # 形式: "Bearer {JWT_TOKEN}"
      IdentitySource: method.request.header.Authorization

  # ========================================
  # Lambda 実行ロール
  # 最小権限の原則に基づく設計
  # ========================================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${EnvironmentName}-lambda-execution-role'
      
      # Lambdaサービスがこのロールを使用可能にする信頼ポリシー
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      
      # AWS管理ポリシーのアタッチ
      ManagedPolicyArns:
        # 基本CloudWatch Logs権限（ログ出力用）
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        # VPC内実行時のネットワークインターフェース管理権限
        - !If 
          - UseVPC
          - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
          - !Ref AWS::NoValue
      # カスタムポリシー: アプリケーション固有の権限設定
      Policies:
        - PolicyName: RestApiLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # DynamoDBアクセス権限（CRUD操作 + インデックス検索）
              - Effect: Allow
                Action:
                  - dynamodb:GetItem        # 単一アイテム取得
                  - dynamodb:PutItem        # アイテム作成
                  - dynamodb:UpdateItem     # アイテム更新
                  - dynamodb:DeleteItem     # アイテム削除
                  - dynamodb:Query          # プライマリキー/GSI検索
                  - dynamodb:Scan           # テーブルスキャン
                # メインテーブル + グローバルセカンダリインデックスへのアクセス
                Resource: 
                  - !GetAtt ItemsTable.Arn           # Itemsテーブル
                  - !Sub '${ItemsTable.Arn}/index/*'  # Items GSI
                  - !GetAtt UsersTable.Arn           # Usersテーブル
                  - !Sub '${UsersTable.Arn}/index/*'  # Users GSI
              
              # S3ファイルストレージ権限（アップロード/ダウンロード/削除）
              - Effect: Allow
                Action:
                  - s3:GetObject    # ファイル取得（ダウンロード）
                  - s3:PutObject    # ファイルアップロード
                  - s3:DeleteObject # ファイル削除
                # ファイルストレージバケット内の全オブジェクト
                Resource: !Sub '${FileStorageBucket}/*'
              
              # SESメール送信権限（通知機能）
              - Effect: Allow
                Action:
                  - ses:SendEmail     # シンプルメール送信
                  - ses:SendRawEmail  # 添付ファイル付きメール送信
                # 全メールアドレスへの送信許可（本番では制限推奨）
                Resource: '*'
              
              # SNSプッシュ通知権限（非同期処理）
              - Effect: Allow
                Action:
                  - sns:Publish # メッセージ発行
                # 特定の通知トピックのみアクセス許可
                Resource: !Ref NotificationTopic

  # ========================================
  # Lambda用セキュリティグループ
  # VPC内Lambdaのネットワークアクセス制御
  # ========================================
  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: UseVPC
    Properties:
      GroupName: !Sub '${ProjectName}-${EnvironmentName}-lambda-sg'
      GroupDescription: Security group for REST API Lambda functions
      VpcId: !Ref VpcId
      
      # アウトバウンドルール: 全トラフィック許可
      # Lambdaが外部APIやAWSサービスにアクセスするため必要
      # 本番では必要なポートのみ許可することを推奨
      SecurityGroupEgress:
        - IpProtocol: -1            # 全プロトコル
          CidrIp: 0.0.0.0/0         # 全IPアドレス
          Description: All outbound traffic
      Tags:
        - Key: Name
          Value: !Sub '${ProjectName}-${EnvironmentName}-lambda-sg'
        - Key: Environment
          Value: !Ref EnvironmentName

  # ========================================
  # Users API Lambda関数
  # ユーザー管理のCRUD操作を提供
  # ========================================
  UsersFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${EnvironmentName}-users'
      Runtime: python3.9              # Python 3.9 ランタイム（安定版）
      Handler: index.lambda_handler     # エントリーポイント関数
      Role: !GetAtt LambdaExecutionRole.Arn  # 実行ロールのARN
      
      # パフォーマンス設定
      Timeout: 30      # 30秒タイムアウト（API Gatewayの最大値）
      MemorySize: 256  # 256MBメモリ（コストとパフォーマンスのバランス）
      
      # VPC設定（セキュリティ強化時のみ）
      VpcConfig: !If
        - UseVPC
        - SecurityGroupIds:
            - !Ref LambdaSecurityGroup  # ネットワークアクセス制御
          SubnetIds: !Ref PrivateSubnetIds  # プライベートサブネット配置
        - !Ref AWS::NoValue  # VPC使用しない場合は設定なし
      
      # 環境変数（アプリケーション設定）
      Environment:
        Variables:
          ENVIRONMENT: !Ref EnvironmentName   # デプロイ環境
          USERS_TABLE: !Ref UsersTable         # ユーザーテーブル名
          ITEMS_TABLE: !Ref ItemsTable         # アイテムテーブル名
          SNS_TOPIC: !Ref NotificationTopic    # 通知トピックARN
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          import uuid
          
          dynamodb = boto3.resource('dynamodb')
          sns = boto3.client('sns')
          
          def lambda_handler(event, context):
              print(f"Users API received: {json.dumps(event, default=str)}")
              
              table_name = os.environ['USERS_TABLE']
              table = dynamodb.Table(table_name)
              sns_topic = os.environ['SNS_TOPIC']
              
              http_method = event['httpMethod']
              path_parameters = event.get('pathParameters') or {}
              query_parameters = event.get('queryStringParameters') or {}
              body = json.loads(event.get('body', '{}'))
              
              try:
                  if http_method == 'GET':
                      if 'userId' in path_parameters:
                          # Get specific user
                          response = table.get_item(Key={'id': path_parameters['userId']})
                          if 'Item' in response:
                              return {
                                  'statusCode': 200,
                                  'headers': {'Content-Type': 'application/json'},
                                  'body': json.dumps(response['Item'], default=str)
                              }
                          else:
                              return {
                                  'statusCode': 404,
                                  'headers': {'Content-Type': 'application/json'},
                                  'body': json.dumps({'error': 'User not found'})
                              }
                      else:
                          # List users
                          limit = int(query_parameters.get('limit', 10))
                          response = table.scan(Limit=limit)
                          return {
                              'statusCode': 200,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({
                                  'users': response['Items'],
                                  'count': len(response['Items'])
                              }, default=str)
                          }
                  
                  elif http_method == 'POST':
                      # Create user
                      user_id = str(uuid.uuid4())
                      user = {
                          'id': user_id,
                          'email': body.get('email'),
                          'name': body.get('name'),
                          'status': 'active',
                          'created_at': datetime.utcnow().isoformat(),
                          'updated_at': datetime.utcnow().isoformat()
                      }
                      
                      table.put_item(Item=user)
                      
                      # Send notification
                      sns.publish(
                          TopicArn=sns_topic,
                          Message=f"New user created: {user['email']}",
                          Subject="New User Registration"
                      )
                      
                      return {
                          'statusCode': 201,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps(user, default=str)
                      }
                  
                  elif http_method == 'PUT':
                      # Update user
                      user_id = path_parameters['userId']
                      update_expr = "SET #name = :name, updated_at = :updated_at"
                      expr_attr_names = {'#name': 'name'}
                      expr_attr_values = {
                          ':name': body.get('name'),
                          ':updated_at': datetime.utcnow().isoformat()
                      }
                      
                      if 'status' in body:
                          update_expr += ", #status = :status"
                          expr_attr_names['#status'] = 'status'
                          expr_attr_values[':status'] = body['status']
                      
                      response = table.update_item(
                          Key={'id': user_id},
                          UpdateExpression=update_expr,
                          ExpressionAttributeNames=expr_attr_names,
                          ExpressionAttributeValues=expr_attr_values,
                          ReturnValues='ALL_NEW'
                      )
                      
                      return {
                          'statusCode': 200,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps(response['Attributes'], default=str)
                      }
                  
                  elif http_method == 'DELETE':
                      # Delete user
                      user_id = path_parameters['userId']
                      table.delete_item(Key={'id': user_id})
                      
                      return {
                          'statusCode': 204,
                          'headers': {'Content-Type': 'application/json'},
                          'body': ''
                      }
                  
                  else:
                      return {
                          'statusCode': 405,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'error': 'Method not allowed'})
                      }
                      
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {'Content-Type': 'application/json'},
                      'body': json.dumps({'error': 'Internal server error'})
                  }
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # Items API Lambda関数 
  # アイテム管理のCRUD操作と高度な検索機能を提供
  # ========================================
  ItemsFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${EnvironmentName}-items'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 256
      VpcConfig: !If
        - UseVPC
        - SecurityGroupIds:
            - !Ref LambdaSecurityGroup
          SubnetIds: !Ref PrivateSubnetIds
        - !Ref AWS::NoValue
      Environment:
        Variables:
          ENVIRONMENT: !Ref EnvironmentName
          ITEMS_TABLE: !Ref ItemsTable
          S3_BUCKET: !Ref FileStorageBucket
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          import uuid
          
          dynamodb = boto3.resource('dynamodb')
          s3 = boto3.client('s3')
          
          def lambda_handler(event, context):
              print(f"Items API received: {json.dumps(event, default=str)}")
              
              table_name = os.environ['ITEMS_TABLE']
              table = dynamodb.Table(table_name)
              bucket_name = os.environ['S3_BUCKET']
              
              http_method = event['httpMethod']
              path_parameters = event.get('pathParameters') or {}
              query_parameters = event.get('queryStringParameters') or {}
              body = json.loads(event.get('body', '{}'))
              
              try:
                  if http_method == 'GET':
                      if 'itemId' in path_parameters:
                          # Get specific item
                          response = table.get_item(Key={'id': path_parameters['itemId']})
                          if 'Item' in response:
                              return {
                                  'statusCode': 200,
                                  'headers': {'Content-Type': 'application/json'},
                                  'body': json.dumps(response['Item'], default=str)
                              }
                          else:
                              return {
                                  'statusCode': 404,
                                  'headers': {'Content-Type': 'application/json'},
                                  'body': json.dumps({'error': 'Item not found'})
                              }
                      else:
                          # List items with filtering
                          filter_expr = None
                          expr_attr_values = {}
                          
                          if 'category' in query_parameters:
                              filter_expr = "category = :category"
                              expr_attr_values[':category'] = query_parameters['category']
                          
                          if 'status' in query_parameters:
                              if filter_expr:
                                  filter_expr += " AND #status = :status"
                              else:
                                  filter_expr = "#status = :status"
                              expr_attr_values[':status'] = query_parameters['status']
                          
                          scan_kwargs = {
                              'Limit': int(query_parameters.get('limit', 10))
                          }
                          
                          if filter_expr:
                              scan_kwargs['FilterExpression'] = filter_expr
                              scan_kwargs['ExpressionAttributeValues'] = expr_attr_values
                              if '#status' in filter_expr:
                                  scan_kwargs['ExpressionAttributeNames'] = {'#status': 'status'}
                          
                          response = table.scan(**scan_kwargs)
                          
                          return {
                              'statusCode': 200,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({
                                  'items': response['Items'],
                                  'count': len(response['Items'])
                              }, default=str)
                          }
                  
                  elif http_method == 'POST':
                      # Create item
                      item_id = str(uuid.uuid4())
                      item = {
                          'id': item_id,
                          'name': body.get('name'),
                          'description': body.get('description'),
                          'category': body.get('category', 'general'),
                          'price': body.get('price', 0),
                          'status': 'active',
                          'created_at': datetime.utcnow().isoformat(),
                          'updated_at': datetime.utcnow().isoformat()
                      }
                      
                      table.put_item(Item=item)
                      
                      return {
                          'statusCode': 201,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps(item, default=str)
                      }
                  
                  elif http_method == 'PUT':
                      # Update item
                      item_id = path_parameters['itemId']
                      update_expr = "SET updated_at = :updated_at"
                      expr_attr_values = {':updated_at': datetime.utcnow().isoformat()}
                      
                      if 'name' in body:
                          update_expr += ", #name = :name"
                          expr_attr_values[':name'] = body['name']
                      
                      if 'description' in body:
                          update_expr += ", description = :description"
                          expr_attr_values[':description'] = body['description']
                      
                      if 'price' in body:
                          update_expr += ", price = :price"
                          expr_attr_values[':price'] = body['price']
                      
                      if 'status' in body:
                          update_expr += ", #status = :status"
                          expr_attr_values[':status'] = body['status']
                      
                      expr_attr_names = {}
                      if '#name' in update_expr:
                          expr_attr_names['#name'] = 'name'
                      if '#status' in update_expr:
                          expr_attr_names['#status'] = 'status'
                      
                      update_kwargs = {
                          'Key': {'id': item_id},
                          'UpdateExpression': update_expr,
                          'ExpressionAttributeValues': expr_attr_values,
                          'ReturnValues': 'ALL_NEW'
                      }
                      
                      if expr_attr_names:
                          update_kwargs['ExpressionAttributeNames'] = expr_attr_names
                      
                      response = table.update_item(**update_kwargs)
                      
                      return {
                          'statusCode': 200,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps(response['Attributes'], default=str)
                      }
                  
                  elif http_method == 'DELETE':
                      # Delete item
                      item_id = path_parameters['itemId']
                      table.delete_item(Key={'id': item_id})
                      
                      return {
                          'statusCode': 204,
                          'headers': {'Content-Type': 'application/json'},
                          'body': ''
                      }
                  
                  else:
                      return {
                          'statusCode': 405,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'error': 'Method not allowed'})
                      }
                      
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {'Content-Type': 'application/json'},
                      'body': json.dumps({'error': 'Internal server error'})
                  }
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # DynamoDBテーブル群
  # NoSQLデータベースで高パフォーマンスを実現
  # ========================================
  
  # ユーザー情報テーブル
  UsersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-${EnvironmentName}-users'
      
      # 課金モード: リクエスト単位課金（コスト最適化）
      # - PAY_PER_REQUEST: 使用量に応じた課金（予測不可能なワークロードに最適）
      # - PROVISIONED: 事前容量設定（予測可能な安定ワークロードに最適）
      BillingMode: PAY_PER_REQUEST
      
      # テーブル属性定義（インデックスで使用する属性のみ定義）
      AttributeDefinitions:
        - AttributeName: id      # ユーザーID（プライマリキー）
          AttributeType: S       # String型
        - AttributeName: email   # メールアドレス（GSI用）
          AttributeType: S       # String型
      
      # プライマリキースキーマ（ユニークアクセスパターン）
      KeySchema:
        - AttributeName: id
          KeyType: HASH          # パーティションキー（分散処理用）
      
      # グローバルセカンダリインデックス（別のアクセスパターン）
      GlobalSecondaryIndexes:
        - IndexName: email-index     # メールアドレスでの検索用
          KeySchema:
            - AttributeName: email
              KeyType: HASH          # emailでの一意検索
          Projection:
            ProjectionType: ALL      # 全属性をインデックスに含める
      
      # DynamoDB Streams（データ変更イベントストリーム）
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES  # 変更前後の値を両方記録
      
      # Point-in-Time Recovery（ポイントインタイムリカバリ）
      # 35日間の任意の時点へのデータ復元が可能
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      
      # 暗号化設定（保存時暗号化）
      SSESpecification:
        SSEEnabled: true  # AWS管理キーでの暗号化有効
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # アイテム情報テーブル（複合インデックス例）
  ItemsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-${EnvironmentName}-items'
      BillingMode: PAY_PER_REQUEST
      
      # 属性定義（複合インデックス用）
      AttributeDefinitions:
        - AttributeName: id          # アイテムID（プライマリキー）
          AttributeType: S
        - AttributeName: category    # カテゴリ（GSIパーティションキー）
          AttributeType: S  
        - AttributeName: created_at  # 作成日時（GSIソートキー）
          AttributeType: S
      
      # プライマリキースキーマ
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      
      # 複合インデックス（カテゴリ別時系列検索）
      GlobalSecondaryIndexes:
        - IndexName: category-created-index
          KeySchema:
            - AttributeName: category    # パーティションキー（カテゴリ別分散）
              KeyType: HASH
            - AttributeName: created_at  # ソートキー（時系列ソート）
              KeyType: RANGE
          Projection:
            ProjectionType: ALL  # 全属性投影（追加クエリ不要）
      
      # データ保護機能（Usersテーブルと同様）
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # S3 ファイルストレージ
  # セキュアでコスト効率的なファイル保存
  # ========================================
  FileStorageBucket:
    Type: AWS::S3::Bucket
    Properties:
      # グローバルユニークなバケット名（AWSアカウントID含む）
      BucketName: !Sub '${ProjectName}-${EnvironmentName}-files-${AWS::AccountId}'
      
      # サーバーサイド暗号化（保存時暗号化）
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256  # AWS S3マネージドキーで暗号化
      
      # パブリックアクセス禁止（セキュリティ強化）
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true          # パブリックACL禁止
        BlockPublicPolicy: true        # パブリックポリシー禁止
        IgnorePublicAcls: true         # パブリックACL無視
        RestrictPublicBuckets: true    # パブリックバケット制限
      
      # バージョニング（ファイル履歴管理）
      VersioningConfiguration:
        Status: Enabled  # ファイル更新時に旧バージョン保持
      
      # ライフサイクル管理（コスト最適化）
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldVersions
            Status: Enabled
            # 30日後に古いバージョンを自動削除
            NoncurrentVersionExpirationInDays: 30
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # SNS 通知トピック
  # 非同期メッセージ配信システム
  # ========================================
  NotificationTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub '${ProjectName}-${EnvironmentName}-notifications'
      DisplayName: !Sub '${ProjectName} ${EnvironmentName} Notifications'
      # メッセージ配信先:
      # - メール通知
      # - SMS通知  
      # - Lambda関数トリガー
      # - SQSキュー送信
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # API Gateway リソース構造
  # RESTful URL構造の定義（/users, /users/{id}, /items, /items/{id}）
  # ========================================
  
  # /users リソース（ユーザー一覧・作成）
  UsersResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt RestApi.RootResourceId  # ルートリソース（/）からの子リソース
      PathPart: users  # URLパス: /users

  # /users/{userId} リソース（個別ユーザー操作）
  UserResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !Ref UsersResource  # /users の子リソース
      PathPart: '{userId}'  # パスパラメータ: ユーザーID

  # /items リソース（アイテム一覧・作成）
  ItemsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !GetAtt RestApi.RootResourceId  # ルートリソースからの子リソース
      PathPart: items  # URLパス: /items

  # /items/{itemId} リソース（個別アイテム操作）
  ItemResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref RestApi
      ParentId: !Ref ItemsResource  # /items の子リソース
      PathPart: '{itemId}'  # パスパラメータ: アイテムID

  # ========================================
  # API Gateway HTTP メソッド定義
  # Lambda統合と認証設定
  # ========================================
  
  # GET /users - ユーザー一覧取得（認証必要）
  UsersGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref UsersResource
      HttpMethod: GET
      
      # 認証設定: Cognito使用時はJWT認証、未使用時は認証なし
      AuthorizationType: !If [UseCognito, COGNITO_USER_POOLS, NONE]
      AuthorizerId: !If [UseCognito, !Ref CognitoAuthorizer, !Ref AWS::NoValue]
      
      # API Key必須設定: レート制限と組み合わせて使用
      ApiKeyRequired: !If [RequireApiKey, true, false]
      
      # Lambda統合設定
      Integration:
        Type: AWS_PROXY  # Lambda Proxy統合（リクエスト/レスポンス自動変換）
        IntegrationHttpMethod: POST  # Lambda呼び出しは常にPOST
        # Lambda関数ARN（実行用URI）
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UsersFunction.Arn}/invocations'

  # POST /users - ユーザー作成（認証不要 - 登録用）
  UsersPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref UsersResource
      HttpMethod: POST
      
      # ユーザー登録は認証不要（アカウント作成のため）
      AuthorizationType: NONE
      ApiKeyRequired: !If [RequireApiKey, true, false]
      
      # 同じLambda関数でメソッド別処理を分岐
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UsersFunction.Arn}/invocations'

  # GET /users/{userId} - 個別ユーザー取得（認証必要）
  UserGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref UserResource
      HttpMethod: GET
      AuthorizationType: !If [UseCognito, COGNITO_USER_POOLS, NONE]
      AuthorizerId: !If [UseCognito, !Ref CognitoAuthorizer, !Ref AWS::NoValue]
      ApiKeyRequired: !If [RequireApiKey, true, false]
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UsersFunction.Arn}/invocations'

  UserPutMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref UserResource
      HttpMethod: PUT
      AuthorizationType: !If [UseCognito, COGNITO_USER_POOLS, NONE]
      AuthorizerId: !If [UseCognito, !Ref CognitoAuthorizer, !Ref AWS::NoValue]
      ApiKeyRequired: !If [RequireApiKey, true, false]
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UsersFunction.Arn}/invocations'

  UserDeleteMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref UserResource
      HttpMethod: DELETE
      AuthorizationType: !If [UseCognito, COGNITO_USER_POOLS, NONE]
      AuthorizerId: !If [UseCognito, !Ref CognitoAuthorizer, !Ref AWS::NoValue]
      ApiKeyRequired: !If [RequireApiKey, true, false]
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UsersFunction.Arn}/invocations'

  ItemsGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref ItemsResource
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: !If [RequireApiKey, true, false]
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ItemsFunction.Arn}/invocations'

  ItemsPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref ItemsResource
      HttpMethod: POST
      AuthorizationType: !If [UseCognito, COGNITO_USER_POOLS, NONE]
      AuthorizerId: !If [UseCognito, !Ref CognitoAuthorizer, !Ref AWS::NoValue]
      ApiKeyRequired: !If [RequireApiKey, true, false]
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ItemsFunction.Arn}/invocations'

  ItemGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref ItemResource
      HttpMethod: GET
      AuthorizationType: NONE
      ApiKeyRequired: !If [RequireApiKey, true, false]
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ItemsFunction.Arn}/invocations'

  ItemPutMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref ItemResource
      HttpMethod: PUT
      AuthorizationType: !If [UseCognito, COGNITO_USER_POOLS, NONE]
      AuthorizerId: !If [UseCognito, !Ref CognitoAuthorizer, !Ref AWS::NoValue]
      ApiKeyRequired: !If [RequireApiKey, true, false]
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ItemsFunction.Arn}/invocations'

  ItemDeleteMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !Ref ItemResource
      HttpMethod: DELETE
      AuthorizationType: !If [UseCognito, COGNITO_USER_POOLS, NONE]
      AuthorizerId: !If [UseCognito, !Ref CognitoAuthorizer, !Ref AWS::NoValue]
      ApiKeyRequired: !If [RequireApiKey, true, false]
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ItemsFunction.Arn}/invocations'

  # Lambda Permissions
  UsersLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref UsersFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub '${RestApi.Arn}/*/*'

  ItemsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ItemsFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub '${RestApi.Arn}/*/*'

  # API Gateway Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - UsersGetMethod
      - UsersPostMethod
      - UserGetMethod
      - UserPutMethod
      - UserDeleteMethod
      - ItemsGetMethod
      - ItemsPostMethod
      - ItemGetMethod
      - ItemPutMethod
      - ItemDeleteMethod
    Properties:
      RestApiId: !Ref RestApi
      StageName: !Ref EnvironmentName

  # API Key (if required)
  ApiKey:
    Type: AWS::ApiGateway::ApiKey
    Condition: RequireApiKey
    Properties:
      Name: !Sub '${ProjectName}-${EnvironmentName}-api-key'
      Description: !Sub 'API Key for ${ProjectName} ${EnvironmentName}'
      Enabled: true
      StageKeys:
        - RestApiId: !Ref RestApi
          StageName: !Ref EnvironmentName

  # ========================================
  # API Gateway スロットリング・レート制限
  # API Keyと組み合わせた使用量制御
  # ========================================
  
  # 使用量プラン（スロットリングとクォータ設定）
  UsagePlan:
    Type: AWS::ApiGateway::UsagePlan
    Condition: RequireApiKey
    Properties:
      UsagePlanName: !Sub '${ProjectName}-${EnvironmentName}-usage-plan'
      Description: !Sub 'Usage plan for ${ProjectName} ${EnvironmentName}'
      
      # 適用APIステージ
      ApiStages:
        - ApiId: !Ref RestApi
          Stage: !Ref EnvironmentName
      
      # スロットリング設定（突発トラフィック対応）
      Throttle:
        BurstLimit: 1000  # バースト制限: 1000リクエスト/秒
        RateLimit: 500    # 継続レート制限: 500リクエスト/秒
      
      # クォータ設定（日次利用制限）
      Quota:
        Limit: 10000  # 1日あたり10,000リクエストまで
        Period: DAY   # 日次リセット

  # Usage Plan Key
  UsagePlanKey:
    Type: AWS::ApiGateway::UsagePlanKey
    Condition: RequireApiKey
    Properties:
      KeyId: !Ref ApiKey
      KeyType: API_KEY
      UsagePlanId: !Ref UsagePlan

  # CloudWatch Log Groups
  UsersLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${ProjectName}-${EnvironmentName}-users'
      RetentionInDays: !If [IsProduction, 90, 7]

  ItemsLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${ProjectName}-${EnvironmentName}-items'
      RetentionInDays: !If [IsProduction, 90, 7]

  # CloudWatch Alarms
  UsersErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${EnvironmentName}-users-errors'
      AlarmDescription: Users Lambda function errors
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref UsersFunction

  ItemsErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${EnvironmentName}-items-errors'
      AlarmDescription: Items Lambda function errors
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 1
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref ItemsFunction

  Api5xxErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${EnvironmentName}-api-5xx-errors'
      AlarmDescription: API Gateway 5xx errors
      MetricName: 5XXError
      Namespace: AWS/ApiGateway
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: ApiName
          Value: !Ref RestApi

Outputs:
  RestApiId:
    Description: REST API ID
    Value: !Ref RestApi
    Export:
      Name: !Sub '${AWS::StackName}-RestApiId'

  RestApiUrl:
    Description: REST API URL
    Value: !Sub 'https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentName}'
    Export:
      Name: !Sub '${AWS::StackName}-RestApiUrl'

  UsersTableName:
    Description: Users DynamoDB Table Name
    Value: !Ref UsersTable
    Export:
      Name: !Sub '${AWS::StackName}-UsersTable'

  ItemsTableName:
    Description: Items DynamoDB Table Name
    Value: !Ref ItemsTable
    Export:
      Name: !Sub '${AWS::StackName}-ItemsTable'

  FileStorageBucket:
    Description: S3 Bucket for file storage
    Value: !Ref FileStorageBucket
    Export:
      Name: !Sub '${AWS::StackName}-FileStorageBucket'

  NotificationTopicArn:
    Description: SNS Topic ARN for notifications
    Value: !Ref NotificationTopic
    Export:
      Name: !Sub '${AWS::StackName}-NotificationTopic'

  ApiKeyId:
    Condition: RequireApiKey
    Description: API Key ID
    Value: !Ref ApiKey
    Export:
      Name: !Sub '${AWS::StackName}-ApiKeyId'