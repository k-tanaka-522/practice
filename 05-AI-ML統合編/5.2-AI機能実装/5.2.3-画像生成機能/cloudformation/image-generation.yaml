AWSTemplateFormatVersion: '2010-09-09'
Description: |
  Bedrock 画像生成システム - AI画像生成・編集基盤
  
  【システム概要】
  Amazon Bedrockの画像生成AIモデルを活用した、スケーラブルな画像生成サービス
  
  ┌─────────────────────────────────────────────────────────────────────┐
  │                    AI画像生成 アーキテクチャ                        │
  ├─────────────────────────────────────────────────────────────────────┤
  │ Client → API Gateway → Lambda → Bedrock AI → S3 → CloudFront      │
  │   ↑           ↑          ↑         ↑         ↑         ↑           │
  │ Web UI    レート制限   非同期処理  AI推論    画像保存   CDN配信      │
  │ Mobile    認証        SQSキュー   モデル    暗号化    グローバル     │
  │ API       制限        バッチ処理   選択      バージョン  キャッシュ   │
  └─────────────────────────────────────────────────────────────────────┘
  
  【主要コンポーネント】
  ◆ API Gateway
    - REST API（同期・非同期リクエスト）
    - レート制限（ユーザー別・時間別）
    - CORS設定（ブラウザ対応）
    - 認証・認可（API Key）
  
  ◆ Lambda Functions
    - Generation API: リクエスト受付・バリデーション・キュー送信
    - Generation Worker: Bedrock呼び出し・画像生成・S3保存
    - 非同期処理パターン（高スループット）
    - 同時実行制御（コスト・リソース管理）
  
  ◆ Amazon Bedrock（AI推論エンジン）
    - Stable Diffusion XL: 高品質画像生成
    - Amazon Titan Image: 高速生成・AWS最適化
    - プロンプトエンジニアリング対応
    - ネガティブプロンプト・スタイル制御
  
  ◆ S3 + CloudFront（画像配信CDN）
    - 生成画像保存（暗号化・バージョニング）
    - グローバルCDN配信（低レイテンシ）
    - ライフサイクル管理（コスト最適化）
    - 入力画像一時保存
  
  ◆ DynamoDB（メタデータ管理）
    - 生成履歴・ステータス管理
    - レート制限カウンター
    - GSI活用（高速検索）
    - TTL自動削除
  
  ◆ SQS（非同期処理キュー）
    - FIFO保証（順序維持）
    - デッドレターキュー（エラー処理）
    - 可視性タイムアウト（長時間処理対応）
    - 重複排除（冪等性保証）
  
  【AI機能詳細】
  ✓ テキストから画像生成（Text-to-Image）
  ✓ 画像編集・変換（Image-to-Image）
  ✓ スタイル転送
  ✓ 解像度・アスペクト比選択
  ✓ 品質・ステップ数調整
  ✓ シード値制御（再現性）
  
  【セキュリティ機能】
  ✓ API Key認証
  ✓ レート制限（分・日単位）
  ✓ 暗号化（保存時・転送時）
  ✓ VPC分離（オプション）
  ✓ 不適切コンテンツフィルタ
  ✓ 監査ログ・追跡
  
  【スケーラビリティ】
  ✓ オートスケーリング（Lambda・DynamoDB）
  ✓ 同時生成数制御
  ✓ キューイングシステム
  ✓ CDNキャッシング
  ✓ 地理的分散
  
  【コスト最適化】
  ✓ Pay-per-use課金
  ✓ 自動ライフサイクル管理
  ✓ 画像圧縮・最適化
  ✓ 使用量制限・アラート
  ✓ リザーブドキャパシティ（オプション）

Parameters:
  EnvironmentName:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]
    Description: |
      環境名
      - dev: 開発環境（基本機能）
      - staging: ステージング環境（負荷テスト対応）
      - prod: 本番環境（高性能・CDN配信）

  ProjectName:
    Type: String
    Default: image-generation
    Description: リソース命名に使用するプロジェクト名

  # BedrockセットアップからのImport
  BedrockStackName:
    Type: String
    Description: |
      Bedrockセットアップスタック名
      bedrock-setup.yamlで作成されたスタック名

  # ========================================
  # Bedrock AI モデル設定パラメータ
  # ========================================
  DefaultImageModel:
    Type: String
    Default: stability.stable-diffusion-xl-v1:0
    AllowedValues: 
      - stability.stable-diffusion-xl-v1:0
      - amazon.titan-image-generator-v1
    Description: |
      デフォルト画像生成AIモデル
      
      【Stable Diffusion XL v1.0】
      - 開発元: Stability AI
      - 特徴: 最高品質の画像生成
      - 解像度: 1024x1024まで対応
      - 用途: アート・デザイン・クリエイティブ
      - 処理時間: 15-30秒程度
      - コスト: 高品質だが料金も高め
      
      【Amazon Titan Image Generator v1】
      - 開発元: Amazon
      - 特徴: AWS最適化・高速処理
      - 解像度: 複数サイズ対応
      - 用途: ビジネス・Webコンテンツ
      - 処理時間: 5-15秒程度
      - コスト: バランス型・AWS統合最適化

  # ========================================
  # 画像品質・解像度設定パラメータ
  # ========================================
  DefaultImageSize:
    Type: String
    Default: 1024x1024
    AllowedValues: 
      - 512x512    # 低解像度・高速生成
      - 768x768    # 中解像度・バランス型
      - 1024x1024  # 高解像度・標準推奨
      - 1152x896   # ポートレート向け
      - 1216x832   # 16:10 ワイド画面
      - 1344x768   # 21:9 超ワイド
      - 1536x640   # パノラマ・バナー用
    Description: |
      デフォルト画像解像度
      
      【解像度とパフォーマンス】
      - 512x512: 高速生成(5-10秒)、低コスト、プロトタイプ用
      - 768x768: 中速生成(10-20秒)、中コスト、一般用途
      - 1024x1024: 高品質(15-30秒)、高コスト、本格用途
      
      【アスペクト比用途】
      - 1:1 (1024x1024): SNS投稿、アイコン、正方形コンテンツ
      - 4:3 (1152x896): 印刷物、プレゼンテーション
      - 16:10 (1216x832): PC画面、Webヘッダー
      - 21:9 (1536x640): 映画的構図、パノラマビュー
      
      ※モデルによりサポート解像度が異なる場合があります

  # ========================================
  # システム性能・制限設定パラメータ
  # ========================================
  MaxConcurrentGenerations:
    Type: Number
    Default: 10
    MinValue: 1
    MaxValue: 100
    Description: |
      同時実行可能な最大画像生成数
      
      【パフォーマンス vs コスト】
      - 1-5: 低コスト、順次処理、小規模サービス
      - 10-20: バランス型、中規模サービス推奨
      - 50-100: 高パフォーマンス、大規模サービス
      
      【設定の影響】
      - Lambda予約済み同時実行数
      - Bedrockモデル呼び出し制限
      - 全体的なシステムコスト
      - レスポンス時間・スループット
      
      ※本番環境では段階的に増加させることを推奨

  ImageRetentionDays:
    Type: Number
    Default: 90
    MinValue: 7
    MaxValue: 2555  # 約7年
    Description: |
      画像自動削除期間（日数）
      
      【保持期間とコスト】
      - 7-30日: 一時的コンテンツ、テスト環境
      - 90日: 標準的なWebコンテンツ（推奨）
      - 365日: 重要なビジネスコンテンツ
      - 2555日: アーカイブ・法的要件対応
      
      【ストレージクラス移行】
      - 0-30日: S3 Standard（高速アクセス）
      - 30-90日: S3 IA（中頻度アクセス）
      - 90日以降: S3 Glacier（アーカイブ）
      
      ※削除後は復元不可、バックアップ戦略を検討

  # ========================================
  # APIレート制限・コスト制御パラメータ
  # ========================================
  ApiRateLimit:
    Type: Number
    Default: 60
    MinValue: 10
    MaxValue: 1000
    Description: |
      APIレート制限（リクエスト/分）
      
      【ユーザー体験とコストのバランス】
      - 10-30リクエスト/分: 低コスト、個人用途
      - 60リクエスト/分: 標準的なビジネス用途（推奨）
      - 100-300リクエスト/分: 大量バッチ処理
      - 500-1000リクエスト/分: エンタープライズ用途
      
      【適用スコープ】
      - 個別ユーザー単位での制限
      - スライディングウィンドウ方式
      - DynamoDBでカウンター管理
      
      ※本番環境ではユーザーグループ別制限も検討

  DailyGenerationLimit:
    Type: Number
    Default: 100
    MinValue: 10
    MaxValue: 10000
    Description: |
      日次画像生成上限（画像/日）
      
      【コスト管理戦略】
      - 10-50画像/日: 個人・スタートアップ用
      - 100画像/日: 中小企業・チーム用（推奨）
      - 500画像/日: 大企業・マーケティングチーム
      - 1000-10000画像/日: エンタープライズ・コンテンツ作成業務
      
      【コスト試算例】
      - 100画像/日 x 30日 = 3000画像/月
      - Stable Diffusion: 約$150-300/月
      - Titan Image: 約$75-150/月
      
      【管理機能】
      - TTL自動リセット（日本時間0:00）
      - 超過時通知アラート
      - 使用量ダッシュボード

Conditions:
  # ========================================
  # 環境別条件分岐
  # パフォーマンス、セキュリティ、コスト設定の動的切り替え
  # ========================================
  
  # 本番環境判定（高パフォーマンス設定用）
  IsProduction: !Equals [!Ref EnvironmentName, 'prod']

Resources:
  # ========================================
  # S3バケット（画像保存・配信）
  # ========================================
  # ========================================
  # S3 ストレージシステム
  # マルチティアコンテンツのライフサイクル管理
  # ========================================
  
  # 生成画像メインストレージ（CDN配信用）
  GeneratedImagesBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-${EnvironmentName}-images-${AWS::AccountId}'
      
      # CDN配信用パブリックアクセス設定
      # CloudFront OAI経由でのみアクセス許可
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false        # OAIアクセスのためfalse
        BlockPublicPolicy: false      # CloudFrontポリシー用
        IgnorePublicAcls: false       # 細かい制御用
        RestrictPublicBuckets: false  # CDN配信のため
      
      # エンタープライズグレード暗号化
      # BedrockスタックからインポートしたKMSキー使用
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms     # KMS暗号化（最高セキュリティ）
              KMSMasterKeyID: 
                Fn::ImportValue: !Sub '${BedrockStackName}-BedrockKMSKey'
            BucketKeyEnabled: true      # コスト最適化用
      
      # バージョニング（本番のみ有効）
      VersioningConfiguration:
        Status: !If [IsProduction, Enabled, Suspended]
      
      # コスト最適化ライフサイクルルール
      LifecycleConfiguration:
        Rules:
          # ステップ1: 標準ストレージ → 低頻度アクセス
          - Id: TransitionToIA
            Status: Enabled
            Transition:
              StorageClass: STANDARD_IA  # 30日後に68%コスト削減
              TransitionInDays: 30
          # ステップ2: IA → アーカイブストレージ
          - Id: TransitionToGlacier
            Status: Enabled
            Transition:
              StorageClass: GLACIER      # 90日後に85%コスト削減
              TransitionInDays: 90
          # ステップ3: 最終自動削除
          - Id: DeleteOldImages
            Status: Enabled
            ExpirationInDays: !Ref ImageRetentionDays  # 設定可能な保持期間
      # CORS設定（ブラウザからの直接アクセス用）
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']       # 全ヘッダー許可
            AllowedMethods: [GET, HEAD] # 読み取りのみ許可
            AllowedOrigins: ['*']       # 全ドメイン許可（本番では制限推奨）
            MaxAge: 3600                # 1時間キャッシュ
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # 入力画像一時ストレージ（プライベート）
  # Image-to-Image機能やアップロード用の一時保存
  InputImagesBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-${EnvironmentName}-inputs-${AWS::AccountId}'
      
      # 完全プライベートアクセス（入力画像保護）
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true         # パブリックACL完全禁止
        BlockPublicPolicy: true       # パブリックポリシー禁止
        IgnorePublicAcls: true        # パブリックACL無視
        RestrictPublicBuckets: true   # パブリックアクセス完全制限
      
      # 入力画像も同様にKMS暗号化
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: 
                Fn::ImportValue: !Sub '${BedrockStackName}-BedrockKMSKey'
            BucketKeyEnabled: true
      
      # 入力画像は短期保持（一時アップロード用）
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldInputs
            Status: Enabled
            ExpirationInDays: !Ref ImageRetentionDays  # 生成画像と同期間保持
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # CloudFront CDN 配信システム
  # グローバルエッジキャッシュで高速画像配信
  # ========================================
  
  # メインCDNディストリビューション
  ImageCDN:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        Comment: !Sub '${ProjectName} ${EnvironmentName} Image CDN'
        DefaultRootObject: index.html
        
        # オリジン設定（S3バケット接続）
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt GeneratedImagesBucket.DomainName
            # OAI経由でセキュアアクセス（S3直接アクセス禁止）
            S3OriginConfig:
              OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${CloudFrontOAI}'
        
        # デフォルトキャッシュ動作（全パス対象）
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https  # HTTP→HTTPS自動リダイレクト
          # AWS管理ポリシー使用（パフォーマンス最適化済み）
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6  # キャッシュ最適化
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf  # CORS-S3対応
          ResponseHeadersPolicyId: 67f7725c-6f97-4210-82d7-5512b31e9d03  # セキュリティヘッダー
        
        # APIパス専用キャッシュ設定（動的コンテンツ用）
        CacheBehaviors:
          - PathPattern: '/api/*'                   # APIパスのみ対象
            TargetOriginId: S3Origin
            ViewerProtocolPolicy: https-only        # HTTPS強制
            CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad  # キャッシュ無効
            OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf
        
        # 料金クラス（地理的配信範囲）
        PriceClass: !If [IsProduction, 'PriceClass_All', 'PriceClass_100']
        # 本番: 全世界配信、開発: 主要地域のみ（コスト最適化）
        
        # SSL証明書設定
        ViewerCertificate:
          CloudFrontDefaultCertificate: true        # デフォルト証明書使用
          # 本番では独自ドメイン・ACM証明書推奨
        
        # プロトコルバージョン設定
        HttpVersion: http2                          # HTTP/2有効（パフォーマンス向上）
        IPV6Enabled: true                           # IPv6対応
        
        # アクセスログ（本番環境のみ）
        Logging: !If 
          - IsProduction
          - Bucket: !GetAtt AccessLogsBucket.DomainName
            Prefix: cloudfront-logs/
          - !Ref 'AWS::NoValue'
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # CloudFront Origin Access Identity（S3セキュアアクセス用）
  CloudFrontOAI:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      OriginAccessIdentityConfig:
        Comment: !Sub '${ProjectName} ${EnvironmentName} OAI'
        # OAIの役割:
        # 1. S3バケットへの直接アクセスを禁止
        # 2. CloudFront経由のみアクセス許可
        # 3. ホットリンキング防止、帯域制御

  # S3バケットアクセスポリシー（CloudFront OAI専用）
  GeneratedImagesBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref GeneratedImagesBucket
      PolicyDocument:
        Statement:
          - Sid: AllowCloudFrontAccess
            Effect: Allow
            # CloudFront OAIのみアクセス許可（他は全て拒否）
            Principal:
              AWS: !Sub 'arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${CloudFrontOAI}'
            Action: 's3:GetObject'      # 読み取りのみ許可
            Resource: !Sub '${GeneratedImagesBucket}/*'  # 全オブジェクト対象

  # アクセスログ用バケット（本番環境のみ）
  AccessLogsBucket:
    Type: AWS::S3::Bucket
    Condition: IsProduction
    Properties:
      BucketName: !Sub '${ProjectName}-${EnvironmentName}-access-logs-${AWS::AccountId}'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldLogs
            Status: Enabled
            ExpirationInDays: 90
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # DynamoDB メタデータ管理システム
  # 生成履歴、ステータス管理、レート制限カウンター
  # ========================================
  
  # 画像生成メイン履歴テーブル
  ImageGenerationHistoryTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-${EnvironmentName}-generation-history'
      
      # コスト最適化課金モード（予測不可能なワークロードに最適）
      BillingMode: PAY_PER_REQUEST
      
      # テーブルスキーマ属性定義（インデックス用のみ）
      AttributeDefinitions:
        - AttributeName: generationId  # 一意生成ID（UUID）
          AttributeType: S
        - AttributeName: userId        # ユーザーID（GSI用）
          AttributeType: S
        - AttributeName: createdAt     # 作成日時（ソート用）
          AttributeType: S
        - AttributeName: status        # 処理状態（pending/processing/completed/failed）
          AttributeType: S
      
      # プライマリキー（個別レコードアクセス用）
      KeySchema:
        - AttributeName: generationId
          KeyType: HASH              # パーティションキー
      
      # グローバルセカンダリインデックス（高速検索用）
      GlobalSecondaryIndexes:
        # ユーザー別履歴検索インデックス
        - IndexName: UserHistoryIndex
          KeySchema:
            - AttributeName: userId      # ユーザー別分類
              KeyType: HASH
            - AttributeName: createdAt   # 時系列ソート（新しい順）
              KeyType: RANGE
          Projection:
            ProjectionType: ALL          # 全属性投影（追加クエリ不要）
        
        # 状態別ジョブ管理インデックス
        - IndexName: StatusIndex
          KeySchema:
            - AttributeName: status      # 処理状態別分類
              KeyType: HASH
            - AttributeName: createdAt   # 古い順で処理管理
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      
      # TTL自動削除（ストレージコスト最適化）
      TimeToLiveSpecification:
        AttributeName: ttl             # UNIXタイムスタンプ属性
        Enabled: true                  # 自動期限削除有効
      
      # DynamoDB Streams（リアルタイム処理用）
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES  # 変更前後両方記録
        # 用途: 状態変更監視、統計情報更新、通知連携
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # レート制限カウンター管理テーブル
  RateLimitTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${ProjectName}-${EnvironmentName}-rate-limits'
      BillingMode: PAY_PER_REQUEST
      
      # シンプルなカウンターテーブル構造
      AttributeDefinitions:
        - AttributeName: userId        # ユーザーID（パーティションキー）
          AttributeType: S
        - AttributeName: limitType     # 制限タイプ（minute:YYYYMMDDHHMM, day:YYYYMMDD）
          AttributeType: S
      
      # 複合キー（ユーザー + 時間単位）
      KeySchema:
        - AttributeName: userId
          KeyType: HASH              # ユーザー別分散
        - AttributeName: limitType   # 時間窓別管理
          KeyType: RANGE
      
      # 自動期限削除（メモリリーク防止）
      TimeToLiveSpecification:
        AttributeName: ttl           # 分カウンター: 2分後、日カウンター: 2日後
        Enabled: true
      
      # データ例:
      # userId="user123", limitType="minute:202412311230" → count=5
      # userId="user123", limitType="day:20241231" → count=45
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # ========================================
  # SQS キュー（非同期処理）
  # ========================================
  # 画像生成キュー
  ImageGenerationQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${ProjectName}-${EnvironmentName}-image-generation.fifo'
      FifoQueue: true
      ContentBasedDeduplication: true
      VisibilityTimeoutSeconds: 900  # 15分
      MessageRetentionPeriod: 1209600  # 14日
      DeadLetterTargetArn: !GetAtt ImageGenerationDLQ.Arn
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ImageGenerationDLQ.Arn
        maxReceiveCount: 3
      KmsMasterKeyId: alias/aws/sqs
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # デッドレターキュー
  ImageGenerationDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${ProjectName}-${EnvironmentName}-image-generation-dlq.fifo'
      FifoQueue: true
      MessageRetentionPeriod: 1209600  # 14日
      KmsMasterKeyId: alias/aws/sqs

  # ========================================
  # Lambda関数群
  # ========================================
  # 画像生成API Lambda
  ImageGenerationApiFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${EnvironmentName}-generation-api'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt ImageGenerationRole.Arn
      Timeout: 300
      MemorySize: 1024
      Environment:
        Variables:
          HISTORY_TABLE: !Ref ImageGenerationHistoryTable
          RATE_LIMIT_TABLE: !Ref RateLimitTable
          GENERATION_QUEUE: !Ref ImageGenerationQueue
          INPUT_BUCKET: !Ref InputImagesBucket
          OUTPUT_BUCKET: !Ref GeneratedImagesBucket
          CDN_DOMAIN: !GetAtt ImageCDN.DomainName
          DEFAULT_MODEL: !Ref DefaultImageModel
          DEFAULT_SIZE: !Ref DefaultImageSize
          API_RATE_LIMIT: !Ref ApiRateLimit
          DAILY_LIMIT: !Ref DailyGenerationLimit
          ENVIRONMENT: !Ref EnvironmentName
          PROJECT_NAME: !Ref ProjectName
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import uuid
          import hashlib
          from datetime import datetime, timedelta
          import base64
          
          dynamodb = boto3.resource('dynamodb')
          sqs = boto3.client('sqs')
          s3 = boto3.client('s3')
          
          def lambda_handler(event, context):
              """画像生成API メインハンドラー"""
              
              try:
                  # HTTPメソッドによる処理分岐
                  http_method = event['httpMethod']
                  path = event['path']
                  
                  if http_method == 'POST' and path.endswith('/generate'):
                      return handle_generate_request(event)
                  elif http_method == 'GET' and path.endswith('/status'):
                      return handle_status_request(event)
                  elif http_method == 'GET' and path.endswith('/history'):
                      return handle_history_request(event)
                  elif http_method == 'POST' and path.endswith('/upload'):
                      return handle_upload_request(event)
                  else:
                      return error_response(404, "Endpoint not found")
                      
              except Exception as e:
                  print(f"Error in image generation API: {str(e)}")
                  return error_response(500, f"Internal server error: {str(e)}")
          
          def handle_generate_request(event):
              """画像生成リクエスト処理"""
              
              try:
                  # リクエストボディ解析
                  request_body = json.loads(event['body'])
                  
                  prompt = request_body.get('prompt', '')
                  negative_prompt = request_body.get('negativePrompt', '')
                  model_id = request_body.get('model', os.environ['DEFAULT_MODEL'])
                  image_size = request_body.get('size', os.environ['DEFAULT_SIZE'])
                  style = request_body.get('style', 'photographic')
                  user_id = request_body.get('userId', 'anonymous')
                  async_mode = request_body.get('async', True)
                  
                  # 入力検証
                  if not prompt or len(prompt.strip()) == 0:
                      return error_response(400, "Prompt is required")
                  
                  if len(prompt) > 1000:
                      return error_response(400, "Prompt too long (max 1000 characters)")
                  
                  # レート制限チェック
                  if not check_rate_limits(user_id):
                      return error_response(429, "Rate limit exceeded")
                  
                  # 生成ID作成
                  generation_id = str(uuid.uuid4())
                  
                  # 履歴に保存
                  save_generation_request(generation_id, user_id, {
                      'prompt': prompt,
                      'negativePrompt': negative_prompt,
                      'model': model_id,
                      'size': image_size,
                      'style': style,
                      'async': async_mode
                  })
                  
                  if async_mode:
                      # 非同期処理：キューに送信
                      queue_message = {
                          'generationId': generation_id,
                          'userId': user_id,
                          'prompt': prompt,
                          'negativePrompt': negative_prompt,
                          'model': model_id,
                          'size': image_size,
                          'style': style,
                          'timestamp': datetime.utcnow().isoformat()
                      }
                      
                      sqs.send_message(
                          QueueUrl=os.environ['GENERATION_QUEUE'],
                          MessageBody=json.dumps(queue_message),
                          MessageGroupId=user_id,
                          MessageDeduplicationId=generation_id
                      )
                      
                      return success_response({
                          'generationId': generation_id,
                          'status': 'queued',
                          'message': 'Image generation queued for processing'
                      }, 202)
                  
                  else:
                      # 同期処理は今回は省略（実装が複雑になるため）
                      return error_response(501, "Synchronous generation not implemented")
                      
              except Exception as e:
                  print(f"Error in generate request: {str(e)}")
                  return error_response(500, f"Error processing request: {str(e)}")
          
          def handle_status_request(event):
              """生成ステータス確認"""
              
              try:
                  query_params = event.get('queryStringParameters', {}) or {}
                  generation_id = query_params.get('id')
                  
                  if not generation_id:
                      return error_response(400, "Generation ID is required")
                  
                  # 履歴から取得
                  history_table = dynamodb.Table(os.environ['HISTORY_TABLE'])
                  
                  response = history_table.get_item(
                      Key={'generationId': generation_id}
                  )
                  
                  if 'Item' not in response:
                      return error_response(404, "Generation not found")
                  
                  item = response['Item']
                  
                  return success_response({
                      'generationId': generation_id,
                      'status': item['status'],
                      'createdAt': item['createdAt'],
                      'completedAt': item.get('completedAt'),
                      'imageUrl': item.get('imageUrl'),
                      'errorMessage': item.get('errorMessage')
                  })
                  
              except Exception as e:
                  print(f"Error in status request: {str(e)}")
                  return error_response(500, f"Error getting status: {str(e)}")
          
          def handle_history_request(event):
              """生成履歴取得"""
              
              try:
                  query_params = event.get('queryStringParameters', {}) or {}
                  user_id = query_params.get('userId', 'anonymous')
                  limit = int(query_params.get('limit', '20'))
                  
                  history_table = dynamodb.Table(os.environ['HISTORY_TABLE'])
                  
                  response = history_table.query(
                      IndexName='UserHistoryIndex',
                      KeyConditionExpression='userId = :uid',
                      ExpressionAttributeValues={':uid': user_id},
                      ScanIndexForward=False,  # 新しい順
                      Limit=limit
                  )
                  
                  items = response.get('Items', [])
                  
                  return success_response({
                      'history': [
                          {
                              'generationId': item['generationId'],
                              'status': item['status'],
                              'prompt': item.get('prompt', ''),
                              'createdAt': item['createdAt'],
                              'imageUrl': item.get('imageUrl')
                          }
                          for item in items
                      ]
                  })
                  
              except Exception as e:
                  print(f"Error in history request: {str(e)}")
                  return error_response(500, f"Error getting history: {str(e)}")
          
          def handle_upload_request(event):
              """入力画像アップロード処理"""
              
              try:
                  # 実装省略：Base64エンコードされた画像をS3にアップロード
                  return success_response({
                      'message': 'Upload functionality not implemented',
                      'uploadUrl': 'placeholder'
                  })
                  
              except Exception as e:
                  print(f"Error in upload request: {str(e)}")
                  return error_response(500, f"Error uploading: {str(e)}")
          
          def check_rate_limits(user_id):
              """レート制限チェック"""
              
              try:
                  rate_limit_table = dynamodb.Table(os.environ['RATE_LIMIT_TABLE'])
                  now = datetime.utcnow()
                  
                  # 分単位制限チェック
                  minute_key = now.strftime('%Y%m%d%H%M')
                  minute_response = rate_limit_table.get_item(
                      Key={'userId': user_id, 'limitType': f'minute:{minute_key}'}
                  )
                  
                  minute_count = minute_response.get('Item', {}).get('count', 0)
                  if minute_count >= int(os.environ['API_RATE_LIMIT']):
                      return False
                  
                  # 日次制限チェック
                  day_key = now.strftime('%Y%m%d')
                  day_response = rate_limit_table.get_item(
                      Key={'userId': user_id, 'limitType': f'day:{day_key}'}
                  )
                  
                  day_count = day_response.get('Item', {}).get('count', 0)
                  if day_count >= int(os.environ['DAILY_LIMIT']):
                      return False
                  
                  # カウンター更新
                  update_rate_limits(user_id, minute_key, day_key)
                  
                  return True
                  
              except Exception as e:
                  print(f"Error checking rate limits: {str(e)}")
                  # エラー時は制限しない（可用性優先）
                  return True
          
          def update_rate_limits(user_id, minute_key, day_key):
              """レート制限カウンター更新"""
              
              rate_limit_table = dynamodb.Table(os.environ['RATE_LIMIT_TABLE'])
              now = datetime.utcnow()
              
              # 分単位カウンター
              minute_ttl = int((now + timedelta(minutes=2)).timestamp())
              rate_limit_table.update_item(
                  Key={'userId': user_id, 'limitType': f'minute:{minute_key}'},
                  UpdateExpression='ADD #count :inc SET #ttl = :ttl',
                  ExpressionAttributeNames={'#count': 'count', '#ttl': 'ttl'},
                  ExpressionAttributeValues={':inc': 1, ':ttl': minute_ttl}
              )
              
              # 日次カウンター
              day_ttl = int((now + timedelta(days=2)).timestamp())
              rate_limit_table.update_item(
                  Key={'userId': user_id, 'limitType': f'day:{day_key}'},
                  UpdateExpression='ADD #count :inc SET #ttl = :ttl',
                  ExpressionAttributeNames={'#count': 'count', '#ttl': 'ttl'},
                  ExpressionAttributeValues={':inc': 1, ':ttl': day_ttl}
              )
          
          def save_generation_request(generation_id, user_id, request_data):
              """生成リクエストを履歴に保存"""
              
              history_table = dynamodb.Table(os.environ['HISTORY_TABLE'])
              
              # TTL設定（画像保持期間と同じ）
              ttl = int((datetime.utcnow() + timedelta(days=90)).timestamp())
              
              history_table.put_item(
                  Item={
                      'generationId': generation_id,
                      'userId': user_id,
                      'status': 'pending',
                      'prompt': request_data.get('prompt', ''),
                      'negativePrompt': request_data.get('negativePrompt', ''),
                      'model': request_data.get('model', ''),
                      'size': request_data.get('size', ''),
                      'style': request_data.get('style', ''),
                      'createdAt': datetime.utcnow().isoformat(),
                      'ttl': ttl
                  }
              )
          
          def success_response(data, status_code=200):
              """成功レスポンス"""
              return {
                  'statusCode': status_code,
                  'headers': {
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type,Authorization',
                      'Access-Control-Allow-Methods': 'GET,POST,OPTIONS'
                  },
                  'body': json.dumps(data, ensure_ascii=False)
              }
          
          def error_response(status_code, message):
              """エラーレスポンス"""
              return {
                  'statusCode': status_code,
                  'headers': {
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type,Authorization',
                      'Access-Control-Allow-Methods': 'GET,POST,OPTIONS'
                  },
                  'body': json.dumps({
                      'error': message
                  }, ensure_ascii=False)
              }
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # 画像生成ワーカーLambda
  ImageGenerationWorkerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${EnvironmentName}-generation-worker'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt ImageGenerationRole.Arn
      Timeout: 900  # 15分
      MemorySize: 3008
      ReservedConcurrencyLimit: !Ref MaxConcurrentGenerations
      Environment:
        Variables:
          HISTORY_TABLE: !Ref ImageGenerationHistoryTable
          OUTPUT_BUCKET: !Ref GeneratedImagesBucket
          CDN_DOMAIN: !GetAtt ImageCDN.DomainName
          ENVIRONMENT: !Ref EnvironmentName
          PROJECT_NAME: !Ref ProjectName
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import uuid
          from datetime import datetime
          import base64
          import hashlib
          
          bedrock_runtime = boto3.client('bedrock-runtime')
          dynamodb = boto3.resource('dynamodb')
          s3 = boto3.client('s3')
          
          def lambda_handler(event, context):
              """SQSトリガーによる画像生成処理"""
              
              try:
                  for record in event['Records']:
                      message_data = json.loads(record['body'])
                      generation_id = message_data['generationId']
                      
                      print(f"Processing image generation: {generation_id}")
                      
                      # ステータス更新（処理中）
                      update_generation_status(generation_id, 'processing')
                      
                      # 画像生成実行
                      image_data = generate_image(message_data)
                      
                      if image_data:
                          # S3に保存
                          image_url = save_image_to_s3(generation_id, image_data)
                          
                          # ステータス更新（完了）
                          update_generation_status(generation_id, 'completed', image_url)
                          
                          print(f"Image generation completed: {generation_id}")
                      else:
                          # ステータス更新（失敗）
                          update_generation_status(generation_id, 'failed', None, 'Failed to generate image')
                          
                          print(f"Image generation failed: {generation_id}")
                  
                  return {'statusCode': 200, 'body': 'Image generation processed'}
                  
              except Exception as e:
                  print(f"Error in image generation worker: {str(e)}")
                  raise e
          
          def generate_image(message_data):
              """Bedrockを使用した画像生成"""
              
              try:
                  model_id = message_data['model']
                  prompt = message_data['prompt']
                  negative_prompt = message_data.get('negativePrompt', '')
                  size = message_data['size']
                  style = message_data.get('style', 'photographic')
                  
                  if model_id.startswith('stability.stable-diffusion'):
                      return generate_with_stable_diffusion(model_id, prompt, negative_prompt, size, style)
                  elif model_id.startswith('amazon.titan-image'):
                      return generate_with_titan_image(model_id, prompt, size)
                  else:
                      print(f"Unsupported model: {model_id}")
                      return None
                      
              except Exception as e:
                  print(f"Error generating image: {str(e)}")
                  return None
          
          def generate_with_stable_diffusion(model_id, prompt, negative_prompt, size, style):
              """Stable Diffusion XL で画像生成"""
              
              # サイズを幅と高さに分解
              width, height = map(int, size.split('x'))
              
              request_body = {
                  "text_prompts": [
                      {
                          "text": prompt,
                          "weight": 1.0
                      }
                  ],
                  "cfg_scale": 7,
                  "seed": 0,
                  "steps": 30,
                  "width": width,
                  "height": height,
                  "style_preset": style
              }
              
              # ネガティブプロンプトがある場合
              if negative_prompt:
                  request_body["text_prompts"].append({
                      "text": negative_prompt,
                      "weight": -1.0
                  })
              
              response = bedrock_runtime.invoke_model(
                  modelId=model_id,
                  body=json.dumps(request_body),
                  contentType="application/json",
                  accept="application/json"
              )
              
              response_body = json.loads(response['body'].read())
              
              if 'artifacts' in response_body and response_body['artifacts']:
                  return response_body['artifacts'][0]['base64']
              
              return None
          
          def generate_with_titan_image(model_id, prompt, size):
              """Titan Image Generator で画像生成"""
              
              # サイズを幅と高さに分解
              width, height = map(int, size.split('x'))
              
              request_body = {
                  "taskType": "TEXT_IMAGE",
                  "textToImageParams": {
                      "text": prompt,
                      "negativeText": "",
                  },
                  "imageGenerationConfig": {
                      "numberOfImages": 1,
                      "quality": "standard",
                      "cfgScale": 8.0,
                      "height": height,
                      "width": width,
                      "seed": 0
                  }
              }
              
              response = bedrock_runtime.invoke_model(
                  modelId=model_id,
                  body=json.dumps(request_body),
                  contentType="application/json",
                  accept="application/json"
              )
              
              response_body = json.loads(response['body'].read())
              
              if 'images' in response_body and response_body['images']:
                  return response_body['images'][0]
              
              return None
          
          def save_image_to_s3(generation_id, image_base64):
              """生成された画像をS3に保存"""
              
              try:
                  # Base64デコード
                  image_data = base64.b64decode(image_base64)
                  
                  # S3キー生成
                  timestamp = datetime.utcnow().strftime('%Y/%m/%d')
                  s3_key = f"generated/{timestamp}/{generation_id}.png"
                  
                  # S3にアップロード
                  s3.put_object(
                      Bucket=os.environ['OUTPUT_BUCKET'],
                      Key=s3_key,
                      Body=image_data,
                      ContentType='image/png',
                      CacheControl='max-age=31536000',  # 1年
                      Metadata={
                          'generation-id': generation_id,
                          'generated-at': datetime.utcnow().isoformat()
                      }
                  )
                  
                  # CDN URL生成
                  cdn_domain = os.environ['CDN_DOMAIN']
                  image_url = f"https://{cdn_domain}/{s3_key}"
                  
                  return image_url
                  
              except Exception as e:
                  print(f"Error saving image to S3: {str(e)}")
                  return None
          
          def update_generation_status(generation_id, status, image_url=None, error_message=None):
              """生成ステータスを更新"""
              
              history_table = dynamodb.Table(os.environ['HISTORY_TABLE'])
              
              update_expression = 'SET #status = :status'
              expression_values = {':status': status}
              expression_names = {'#status': 'status'}
              
              if status == 'completed':
                  update_expression += ', completedAt = :completed'
                  expression_values[':completed'] = datetime.utcnow().isoformat()
                  
                  if image_url:
                      update_expression += ', imageUrl = :url'
                      expression_values[':url'] = image_url
              
              if status == 'failed' and error_message:
                  update_expression += ', errorMessage = :error'
                  expression_values[':error'] = error_message
              
              history_table.update_item(
                  Key={'generationId': generation_id},
                  UpdateExpression=update_expression,
                  ExpressionAttributeNames=expression_names,
                  ExpressionAttributeValues=expression_values
              )
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # SQSトリガー設定
  ImageGenerationEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt ImageGenerationQueue.Arn
      FunctionName: !Ref ImageGenerationWorkerFunction
      BatchSize: 1
      MaximumBatchingWindowInSeconds: 5

  # ========================================
  # API Gateway REST API
  # ========================================
  # REST API
  ImageGenerationApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub '${ProjectName}-${EnvironmentName}-image-generation-api'
      Description: AI Image Generation API
      EndpointConfiguration:
        Types:
          - REGIONAL
      BinaryMediaTypes:
        - image/png
        - image/jpeg
        - image/gif
        - image/webp

  # API Gateway リソース
  GenerateResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ParentId: !GetAtt ImageGenerationApi.RootResourceId
      PathPart: generate

  StatusResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ParentId: !GetAtt ImageGenerationApi.RootResourceId
      PathPart: status

  HistoryResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ParentId: !GetAtt ImageGenerationApi.RootResourceId
      PathPart: history

  UploadResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ParentId: !GetAtt ImageGenerationApi.RootResourceId
      PathPart: upload

  # POST メソッド（生成）
  GenerateMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ResourceId: !Ref GenerateResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ImageGenerationApiFunction.Arn}/invocations'
      MethodResponses:
        - StatusCode: 200
        - StatusCode: 202
        - StatusCode: 400
        - StatusCode: 429
        - StatusCode: 500

  # GET メソッド（ステータス）
  StatusMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ResourceId: !Ref StatusResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ImageGenerationApiFunction.Arn}/invocations'

  # GET メソッド（履歴）
  HistoryMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ResourceId: !Ref HistoryResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ImageGenerationApiFunction.Arn}/invocations'

  # POST メソッド（アップロード）
  UploadMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ResourceId: !Ref UploadResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ImageGenerationApiFunction.Arn}/invocations'

  # CORS設定
  GenerateOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ImageGenerationApi
      ResourceId: !Ref GenerateResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,Authorization'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'*'"
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: false
            method.response.header.Access-Control-Allow-Methods: false
            method.response.header.Access-Control-Allow-Origin: false

  # API デプロイメント
  ImageApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - GenerateMethod
      - StatusMethod
      - HistoryMethod
      - UploadMethod
      - GenerateOptionsMethod
    Properties:
      RestApiId: !Ref ImageGenerationApi
      Description: !Sub '${EnvironmentName} deployment'

  # API ステージ
  ImageApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      RestApiId: !Ref ImageGenerationApi
      DeploymentId: !Ref ImageApiDeployment
      StageName: !Ref EnvironmentName
      ThrottleSettings:
        RateLimit: !Ref ApiRateLimit
        BurstLimit: !Ref MaxConcurrentGenerations
      MethodSettings:
        - ResourcePath: '/*'
          HttpMethod: '*'
          LoggingLevel: !If [IsProduction, ERROR, INFO]
          DataTraceEnabled: !If [IsProduction, false, true]
          MetricsEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentName
        - Key: Project
          Value: !Ref ProjectName

  # Lambda実行権限
  ImageGenerationApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ImageGenerationApiFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ImageGenerationApi}/*'

  # ========================================
  # IAMロール
  # ========================================
  ImageGenerationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ImageGenerationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: 
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/stability.stable-diffusion-*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/amazon.titan-image-*'
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                  - dynamodb:GetItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                Resource:
                  - !GetAtt ImageGenerationHistoryTable.Arn
                  - !Sub '${ImageGenerationHistoryTable.Arn}/index/*'
                  - !GetAtt RateLimitTable.Arn
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                Resource:
                  - !Sub '${InputImagesBucket}/*'
                  - !Sub '${GeneratedImagesBucket}/*'
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                Resource: 
                  - !GetAtt ImageGenerationQueue.Arn
              - Effect: Allow
                Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                Resource: 
                  Fn::ImportValue: !Sub '${BedrockStackName}-BedrockKMSKeyArn'

  # ========================================
  # CloudWatch 監視
  # ========================================
  # Lambda ログ
  ImageGenerationApiLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${ProjectName}-${EnvironmentName}-generation-api'
      RetentionInDays: !If [IsProduction, 30, 7]

  ImageGenerationWorkerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${ProjectName}-${EnvironmentName}-generation-worker'
      RetentionInDays: !If [IsProduction, 30, 7]

  # 高エラー率アラーム
  ImageGenerationErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${EnvironmentName}-image-generation-errors'
      AlarmDescription: Image generation error rate is high
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 5
      ComparisonOperator: GreaterThanThreshold
      TreatMissingData: notBreaching
      Dimensions:
        - Name: FunctionName
          Value: !Ref ImageGenerationWorkerFunction

  # 長時間処理アラーム
  ImageGenerationDurationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${EnvironmentName}-image-generation-duration'
      AlarmDescription: Image generation duration is high
      MetricName: Duration
      Namespace: AWS/Lambda
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 600000  # 10分
      ComparisonOperator: GreaterThanThreshold
      TreatMissingData: notBreaching
      Dimensions:
        - Name: FunctionName
          Value: !Ref ImageGenerationWorkerFunction

# ========================================
# 出力値（他のスタックから参照可能）
# ========================================
Outputs:
  # API エンドポイント
  ImageGenerationApiEndpoint:
    Description: Image Generation API エンドポイント
    Value: !Sub 'https://${ImageGenerationApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentName}'
    Export:
      Name: !Sub '${AWS::StackName}-ImageGenerationApiEndpoint'

  # CDN情報
  ImageCDNDomain:
    Description: 画像配信CDNドメイン
    Value: !GetAtt ImageCDN.DomainName
    Export:
      Name: !Sub '${AWS::StackName}-ImageCDNDomain'

  ImageCDNURL:
    Description: 画像配信CDNURL
    Value: !Sub 'https://${ImageCDN.DomainName}'

  # S3バケット
  GeneratedImagesBucketName:
    Description: 生成画像保存S3バケット名
    Value: !Ref GeneratedImagesBucket
    Export:
      Name: !Sub '${AWS::StackName}-GeneratedImagesBucket'

  InputImagesBucketName:
    Description: 入力画像保存S3バケット名
    Value: !Ref InputImagesBucket
    Export:
      Name: !Sub '${AWS::StackName}-InputImagesBucket'

  # Lambda関数
  ImageGenerationApiFunctionArn:
    Description: 画像生成API Lambda関数ARN
    Value: !GetAtt ImageGenerationApiFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-ImageGenerationApiFunction'

  ImageGenerationWorkerFunctionArn:
    Description: 画像生成ワーカーLambda関数ARN
    Value: !GetAtt ImageGenerationWorkerFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-ImageGenerationWorkerFunction'

  # DynamoDB テーブル
  ImageGenerationHistoryTableName:
    Description: 画像生成履歴テーブル名
    Value: !Ref ImageGenerationHistoryTable
    Export:
      Name: !Sub '${AWS::StackName}-ImageGenerationHistoryTable'

  # SQS キュー
  ImageGenerationQueueUrl:
    Description: 画像生成キューURL
    Value: !Ref ImageGenerationQueue
    Export:
      Name: !Sub '${AWS::StackName}-ImageGenerationQueue'

  # 使用例
  ImageGenerationUsageExample:
    Description: 画像生成API使用例
    Value: !Sub |
      画像生成システム使用例:
      
      1. 画像生成リクエスト:
      curl -X POST ${ImageGenerationApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentName}/generate \
        -H "Content-Type: application/json" \
        -d '{
          "prompt": "A beautiful sunset over mountains",
          "model": "${DefaultImageModel}",
          "size": "${DefaultImageSize}",
          "userId": "user123",
          "async": true
        }'
      
      2. 生成ステータス確認:
      curl "${ImageGenerationApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentName}/status?id=GENERATION_ID"
      
      3. 生成履歴取得:
      curl "${ImageGenerationApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentName}/history?userId=user123"

  # 設定概要
  ImageGenerationConfiguration:
    Description: 画像生成システム設定概要
    Value: !Sub |
      Image Generation System:
      - API: https://${ImageGenerationApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentName}
      - CDN: https://${ImageCDN.DomainName}
      - Default Model: ${DefaultImageModel}
      - Default Size: ${DefaultImageSize}
      - Rate Limit: ${ApiRateLimit}/min
      - Daily Limit: ${DailyGenerationLimit}/day
      - Max Concurrent: ${MaxConcurrentGenerations}
      - Images Bucket: s3://${GeneratedImagesBucket}/
      - Retention: ${ImageRetentionDays} days